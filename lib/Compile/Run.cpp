/*
 * Copyright (c) 2020 Trail of Bits, Inc.
 */

#include "Compiler.h"

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wimplicit-int-conversion"
#pragma clang diagnostic ignored "-Wsign-conversion"
#pragma clang diagnostic ignored "-Wshorten-64-to-32"
#include <clang/AST/ASTConsumer.h>
#include <clang/Basic/Diagnostic.h>
#include <clang/Basic/DiagnosticIDs.h>
#include <clang/Basic/DiagnosticOptions.h>
#include <clang/Basic/TargetInfo.h>
#include <clang/Basic/TargetOptions.h>
#include <clang/Frontend/CompilerInstance.h>
#include <clang/Lex/Preprocessor.h>
#include <clang/Lex/PreprocessorOptions.h>
#include <clang/Parse/Parser.h>
#include <clang/Sema/Sema.h>
#pragma clang diagnostic pop

#include <pasta/Util/ArgumentVector.h>

namespace pasta {
namespace {

class SaveFirstErrorDiagConsumer : public clang::DiagnosticConsumer {
 public:
  virtual ~SaveFirstErrorDiagConsumer(void) = default;
  virtual void anchor(void) {}

  void HandleDiagnostic(clang::DiagnosticsEngine::Level level,
                        const clang::Diagnostic &info) override {
    if (clang::DiagnosticsEngine::Error == level ||
        clang::DiagnosticsEngine::Fatal == level) {
      llvm::SmallString<100> data;
      info.FormatDiagnostic(data);
      data.str().str().swap(error);
    }
  }

  std::string error;
};

}  // namespace

// Run a command ans return the AST or the first error.
llvm::Expected<AST> Compiler::Run(const CompileJob &job) const {

  auto real_vfs = llvm::vfs::createPhysicalFileSystem();
  auto overlay_vfs = std::make_unique<llvm::vfs::OverlayFileSystem>();
  auto mem_vfs = std::make_unique<llvm::vfs::InMemoryFileSystem>();
  overlay_vfs->pushOverlay(llvm::vfs::getRealFileSystem());
  overlay_vfs->pushOverlay(mem_vfs.get());
  overlay_vfs->setCurrentWorkingDirectory(working_dir.data());

  auto diag = std::make_unique<SaveFirstErrorDiagConsumer>();
  auto ci = std::make_shared<clang::CompilerInstance>();
  llvm::IntrusiveRefCntPtr<clang::DiagnosticsEngine> diagnostics_engine(
      new clang::DiagnosticsEngine(
          new clang::DiagnosticIDs,
          new clang::DiagnosticOptions,
          diag.get(),
          false  /* DON'T take ownership of the consumer */));

  diagnostics_engine->Reset();
  diagnostics_engine->setIgnoreAllWarnings(true);
  diagnostics_engine->setWarningsAsErrors(false);

  ci->setDiagnostics(diagnostics_engine.get());
  ci->setASTConsumer(std::make_unique<clang::ASTConsumer>());

  auto &invocation = ci->getInvocation();
  auto &fs_options = invocation.getFileSystemOpts();
  fs_options.WorkingDir = working_dir;

  llvm::IntrusiveRefCntPtr<clang::FileManager> fm(
      new clang::FileManager(fs_options, overlay_vfs.get()));

  ci->setFileManager(fm.get());
  ci->createSourceManager(*fm);

  // Make sure the compiler instance is starting with the approximately
  // the right cross-compilation target info.
  auto &target_opts = invocation.getTargetOpts();
  target_opts.HostTriple = llvm::sys::getDefaultTargetTriple();
  target_opts.Triple = target_opts.HostTriple;
  ci->setTarget(clang::TargetInfo::CreateTargetInfo(
      ci->getDiagnostics(), invocation.TargetOpts));

  const auto invocation_is_valid = clang::CompilerInvocation::CreateFromArgs(
      invocation,
      argv.Argv(), &(argv.Argv()[argv.Size()]),
      *diagnostics_engine);

  if (!invocation_is_valid) {
    return llvm::createStringError(
        std::make_error_code(std::errc::invalid_argument),
        "Unable to create compiler invocation from command: %s",
        argv.Join().c_str());
  }

  // Just in case parsing of the command-line args changed this.
  diagnostics_engine->setConstexprBacktraceLimit(0);
  diagnostics_engine->setTemplateBacktraceLimit(0);
  diagnostics_engine->setErrorLimit(1);
  diagnostics_engine->setIgnoreAllWarnings(true);
  diagnostics_engine->setWarningsAsErrors(false);

  // TODO(pag): Consider setting `UsePredefines` to `false` and using an
  //            `-include` file generated by `mu-import` to deal with platform
  //            and compiler differences.
  //
  // TODO(pag): Generate said pre-define include file.
  //
  // TODO(pag): We can possibly also emit implicitly generated functions
  //            and typedefs (via pretty printing) to this file, and also
  //            disable their generation. This will then hopefully mean
  //            fewer implicit decls in the indexer.
  auto &pp_options = invocation.getPreprocessorOpts();
  pp_options.DetailedRecord = true;
  pp_options.SingleFileParseMode = false;
  pp_options.LexEditorPlaceholders = false;
  pp_options.RetainRemappedFileBuffers = true;

  auto &ppo_options = invocation.getPreprocessorOutputOpts();
  ppo_options = {};  // Reset to defaults.

  const auto lang_opts = invocation.getLangOpts();

  lang_opts->EmitAllDecls = true;
  lang_opts->CXXExceptions = true;
  lang_opts->Blocks = true;
  lang_opts->POSIXThreads = true;
  lang_opts->DoubleSquareBracketAttributes = true;
  lang_opts->GNUMode = true;
  lang_opts->GNUKeywords = true;
  lang_opts->GNUAsm = true;
  lang_opts->SpellChecking = false;
  lang_opts->RetainCommentsFromSystemHeaders = false;
  lang_opts->AllowEditorPlaceholders = false;
  lang_opts->CommentOpts.ParseAllComments = false;

  // Affects `PPCallbacks`, and also does additional parsing of things in
  // Objective-C mode, e.g. parsing module imports.
  lang_opts->DebuggerSupport = true;

  // TODO(pag): Should pragmas be ignored?

  // Enable C++-style comments, even in C code. If we don't do this, then we
  // can observe two tokens for something like `// foo` in C code, one is a
  // `slash`, the second is a `comment`.
  lang_opts->LineComment = true;

  // Don't get whitespace.
  lang_opts->TraditionalCPP = false;

  auto &frontend_opts = invocation.getFrontendOpts();
  frontend_opts.StatsFile.clear();

  // Go check that we've got an input file, them initialize the source manager
  // with the first input file.
  auto &input_files = frontend_opts.Inputs;
  if (input_files.empty()) {
    return llvm::createStringError(
        std::make_error_code(std::errc::no_such_file_or_directory),
        "No input file in compilation command: %s",
        argv.Join().c_str());

  // There should only be one input files, as we're dealing with `-cc1`
  // commands, not frontend commands.
  } else if (1u < input_files.size()) {
    return llvm::createStringError(
        std::make_error_code(std::errc::too_many_files_open),
        "Too many input files in compilation command: %s",
        argv.Join().c_str());
  }

  // Go force in the language type using the compiler's target language.
  auto &file = input_files[0];
  switch (impl->target_lang) {
    case TargetLanguage::kC:
      file = clang::FrontendInputFile(
          file.getFile(), clang::InputKind::C, false);
      break;
    case TargetLanguage::kCXX:
      file = clang::FrontendInputFile(
          file.getFile(), clang::InputKind::CXX, false);
      break;
  }

  auto &invocation_target = ci->getTarget();

  // Create TargetInfo for the other side of CUDA and OpenMP compilation.
  if ((lang_opts->CUDA || lang_opts->OpenMPIsDevice) &&
      !frontend_opts.AuxTriple.empty()) {
    auto aux_target = std::make_shared<clang::TargetOptions>();
    aux_target->Triple = llvm::Triple::normalize(frontend_opts.AuxTriple);
    aux_target->HostTriple = invocation_target.getTriple().str();
    ci->setAuxTarget(clang::TargetInfo::CreateTargetInfo(
        *diagnostics_engine, aux_target));
  }

  invocation_target.adjust(*lang_opts);
  invocation_target.adjustTargetOptions(
      ci->getCodeGenOpts(), ci->getTargetOpts());

  if (auto aux_target = ci->getAuxTarget(); aux_target) {
    invocation_target.setAuxTarget(aux_target);
  }

  // Clear out any dependency file stuff. Sometimes the paths for the depdency
  // files are incorrect, and that shouldn't hold up a build.
  auto &dep_opts = ci->getDependencyOutputOpts();
  dep_opts = clang::DependencyOutputOptions();

  // TODO(pag): Eventually add `PPCallbacks` so that we can capture macro
  //            definitions as tokens.

  ci->createPreprocessor(clang::TU_Complete);
  auto &pp = ci->getPreprocessor();

  pp.SetCommentRetentionState(true /* KeepComments */,
                              true /* KeepMacroComments */);

  pp.getBuiltinInfo().initializeBuiltins(pp.getIdentifierTable(), *lang_opts);
  pp.setPragmasEnabled(true);

  // Picks up on the pre-processor and stuff.
  ci->InitializeSourceManager(input_files[0]);
  ci->createASTContext();

  auto &source_manager = ci->getSourceManager();
  auto &ast_context = ci->getASTContext();
  auto &ast_consumer = ci->getASTConsumer();
}

}  // namespace pasta
